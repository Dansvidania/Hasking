
==================== FINAL INTERFACE ====================
2016-12-04 10:27:50.092169 UTC

interface experiments-0.1.0.0-6GFn0ZiyRqI4SNp7TK7sqS:Optional 8001
  interface hash: d1f7b8484f68f43670aa1c00a28e1e39
  ABI hash: 05d142e32559508d163e79d34aaaac6c
  export-list hash: e32a1b39b9d63dab036f254114e9c6eb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Optional.Optional{Optional.Nada Optional.Only}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
141acabe73229343c1881751ccbfca38
  $fEqOptional ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Optional.Optional a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Optional.Optional a)
                  (Optional.$fEqOptional_$c== @ a $dEq)
                  (Optional.$fEqOptional_$c/= @ a $dEq) -}
141acabe73229343c1881751ccbfca38
  $fEqOptional_$c/= ::
    GHC.Classes.Eq a =>
    Optional.Optional a -> Optional.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Optional.Optional a)
                   (b :: Optional.Optional a) ->
                 case a1 of wild {
                   Optional.Nada
                   -> case b of wild1 {
                        Optional.Nada -> GHC.Types.False
                        Optional.Only ipv -> GHC.Types.True }
                   Optional.Only a2
                   -> case b of wild1 {
                        Optional.Nada -> GHC.Types.True
                        Optional.Only b1
                        -> case GHC.Classes.== @ a $dEq a2 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
141acabe73229343c1881751ccbfca38
  $fEqOptional_$c== ::
    GHC.Classes.Eq a =>
    Optional.Optional a -> Optional.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: Optional.Optional a)
                   (ds1 :: Optional.Optional a) ->
                 case ds of wild {
                   Optional.Nada
                   -> case ds1 of wild1 {
                        Optional.Nada -> GHC.Types.True
                        Optional.Only ipv -> GHC.Types.False }
                   Optional.Only a1
                   -> case ds1 of wild1 {
                        Optional.Nada -> GHC.Types.False
                        Optional.Only b1 -> GHC.Classes.== @ a $dEq a1 b1 } }) -}
141acabe73229343c1881751ccbfca38
  $fMonoidOptional ::
    GHC.Base.Monoid a => GHC.Base.Monoid (Optional.Optional a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dMonoid :: GHC.Base.Monoid a).
                  @ (Optional.Optional a)
                  (Optional.$fMonoidOptional_$cmempty @ a $dMonoid)
                  (Optional.$fMonoidOptional_$cmappend @ a $dMonoid)
                  (Optional.$fMonoidOptional_$cmconcat @ a $dMonoid) -}
141acabe73229343c1881751ccbfca38
  $fMonoidOptional_$cmappend ::
    GHC.Base.Monoid a =>
    Optional.Optional a -> Optional.Optional a -> Optional.Optional a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dMonoid :: GHC.Base.Monoid a)
                   (ds :: Optional.Optional a)
                   (x :: Optional.Optional a) ->
                 case ds of wild {
                   Optional.Nada -> x
                   Optional.Only ipv
                   -> case x of wild1 {
                        Optional.Nada -> wild
                        Optional.Only ipv1
                        -> Optional.Only
                             @ a
                             (GHC.Base.mappend @ a $dMonoid ipv ipv1) } }) -}
141acabe73229343c1881751ccbfca38
  $fMonoidOptional_$cmconcat ::
    GHC.Base.Monoid a => [Optional.Optional a] -> Optional.Optional a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(A,C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dMonoid :: GHC.Base.Monoid a)
                   (eta :: [Optional.Optional a]) ->
                 letrec {
                   go :: [Optional.Optional a] -> Optional.Optional a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Optional.Optional a]) ->
                     case ds of wild {
                       [] -> Optional.Nada @ a
                       : y ys
                       -> case y of wild1 {
                            Optional.Nada -> go ys
                            Optional.Only ipv
                            -> case go ys of wild2 {
                                 Optional.Nada -> wild1
                                 Optional.Only ipv1
                                 -> Optional.Only @ a (GHC.Base.mappend @ a $dMonoid ipv ipv1) } } }
                 } in
                 go eta) -}
141acabe73229343c1881751ccbfca38
  $fMonoidOptional_$cmempty ::
    GHC.Base.Monoid a => Optional.Optional a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a ($dMonoid :: GHC.Base.Monoid a) -> Optional.Nada @ a) -}
141acabe73229343c1881751ccbfca38
  $fShowOptional ::
    GHC.Show.Show a => GHC.Show.Show (Optional.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Optional.Optional a)
                  (Optional.$fShowOptional_$cshowsPrec @ a $dShow)
                  (Optional.$fShowOptional_$cshow @ a $dShow)
                  (Optional.$fShowOptional_$cshowList @ a $dShow) -}
84c46f88bcdd82dcc851166f75aedf9b
  $fShowOptional1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
f119ebb321d2d50d82f12849a1ec8dfc
  $fShowOptional2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Only "#) -}
b8bf8afc5af7eab00e5136e53168f719
  $fShowOptional3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
0128f219553da569546fc8d95dcbc895
  $fShowOptional4 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Optional.$fShowOptional5) -}
db8543410c30179b65da6b58860a95f2
  $fShowOptional5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Nada"#) -}
141acabe73229343c1881751ccbfca38
  $fShowOptional_$cshow ::
    GHC.Show.Show a => Optional.Optional a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Optional.Optional a) ->
                 case x of wild {
                   Optional.Nada -> Optional.$fShowOptional5
                   Optional.Only b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Optional.$fShowOptional2
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           Optional.$fShowOptional3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
141acabe73229343c1881751ccbfca38
  $fShowOptional_$cshowList ::
    GHC.Show.Show a => [Optional.Optional a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Optional.Optional a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Optional.Optional a)
                   (Optional.$fShowOptional_$cshowsPrec
                      @ a
                      $dShow
                      Optional.$fShowOptional1)
                   eta
                   eta1) -}
141acabe73229343c1881751ccbfca38
  $fShowOptional_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Optional.Optional a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: Optional.Optional a) ->
                 case ds1 of wild {
                   Optional.Nada -> Optional.$fShowOptional4
                   Optional.Only b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow Optional.$fShowOptional3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Optional.$fShowOptional2 (g x1)
                        GHC.Types.True
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Optional.$fShowOptional2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x1))) } } }) -}
1b844f57cc0632a118803f8c66f4f581
  $tc'Nada :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5413824988526047824##
                   1696263185294116316##
                   Optional.$trModule
                   Optional.$tc'Nada1) -}
6c4a70ba0fa60e0c8c7c3c5d90b3459c
  $tc'Nada1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Nada"#) -}
3a0d1921b0ce68588a533d1236a6b8cc
  $tc'Only :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12813519853623198702##
                   15126154982241136192##
                   Optional.$trModule
                   Optional.$tc'Only1) -}
d02b0b5a641a11c3541711f6e6d7229b
  $tc'Only1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Only"#) -}
773c233175743271a3a8837554e4f5d5
  $tcOptional :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5581893403166196034##
                   7427850469548403697##
                   Optional.$trModule
                   Optional.$trModule1) -}
2c23522ed54fdd7af4e06a74a04a3725
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Optional.$trModule2
                   Optional.$trModule1) -}
bb4b81affcaa4c4a38f1ee75d73bd847
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Optional"#) -}
076c10b8e35a23a7a0b7f6213b5ef678
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "experiments-0.1.0.0-6GFn0ZiyRqI4SNp7TK7sqS"#) -}
141acabe73229343c1881751ccbfca38
  data Optional a = Nada | Only a
instance [safe] GHC.Classes.Eq [Optional.Optional]
  = Optional.$fEqOptional
instance [safe] GHC.Base.Monoid [Optional.Optional]
  = Optional.$fMonoidOptional
instance [safe] GHC.Show.Show [Optional.Optional]
  = Optional.$fShowOptional
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

